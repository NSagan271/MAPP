TODOs: 
-1. make transient run at least 10 times faster, otherwise I'm not presenting it
    Jacobian bypass
    hard code some derivatives for built-in devices
2. LTE based step control is very important for tran_inverter, otherwise the
   plots are ugly
-3. has to get GUI of HSPICE or SPECTRE running on hagrid or elsewhere, for the
   purpose of presentation (not using wv waveviewer)
4. after discussion of gmin, smoothing, limiting and everything, try to put them
   back in Verilog-A and see if it makes a difference
-5. find some cases where HSPICE/SPECTRE breaks, or at least learn from the
   detailed log information whether it used some hack/trick for the circuits to
   converge
   find evidences that HSPICE/SPECTRE is doing the same/similar as MDE
    dc_inverter with Vin=0, .op
     **warning** the following singular supplies were terminated to 1 meg resistor
      supply  node1    node2
      vsource 0:source          defined in subckt 0  0:0 defined in subckt 0
    Note: this is nothing. It only indicates Vsource is floating
-6. Is there a ".ic" equivalent mechanism in dot_transient?
   ring oscillator is not working properly
7. periodical pulse function
8. somehow visualize NR
   add printing for debug level 2
-9. dc sweep w.r.t. two inputs and plotting by surf()
10. document add_to_ee_model
11. pass NRparms and LMSparms through  dot_op dot_tran?

-X. something else:
   SILVACO - A Sophisticated Verilog-A Debugger

Notes: 

1. try HSPICE/Spectre test circuits
    mvs_1_0_0
        characteristic curves
        DC inverter
        3-stage ring oscillators
        5-stage ring oscillators
    mvs_1_0_1
        characteristic curves
        DC inverter
        3-stage ring oscillators
        5-stage ring oscillators

2. move MVS_1_0_0 to the new cktnetlist/dot_* format, retry if they work
   move MVS (Jaijeet's) to the new cktnetlist/dot_* format, retry if they work

 - ModSpec:
    - MVS_1_0_ModSpec_auto.m                                                done
    - MVS_1_0_ModSpec.m                                                     done
    - MVSModSpec.m                                                          done
    - DAAV6ModSpec.m                                                        done

    - test_MVS_1_0_auto_fqei.m   move to 3-D plot  done, doesn't work, all zeros
    - test_MVS_1_0_fqei.m                                                   done
    - test_MVSModSpec_fqei.m (new file)                                     done
    - test_DAAV6ModSpec_fqei.m (new file)                                   done

    - test_MVS_1_0_df.m    move to 3-D plot                                 done
        figure 1 and 3 seem not smooth
        figure 1 is dvecWdvecX(1, 1); KCL-di / Vdib
        figure 3 is dvecWdvecX(2, 1); KCL-si / Vdib

    - test_MVS_1_0_auto_df.m                                 done, doesnt' work 

        "In an assignment  A(I) = B, the number of elements in B and I must be
        the same.
        Error in MVS_1_0_ModSpec_auto>fqei (line 273)
        Vn(terminalInNodes) = vecX;"

    - test_MVS_df.m (new file)                                              done
    - test_DAAV6ModSpec_df.m (new file)                                     done

 - DAEs:
    - MVS_1_0_defaultparms_char_curves_ckt.m (new file)                     done
    - MVS_1_0_char_curves_ckt.m (new file)                                  done
    - MVS_char_curves_ckt.m (new file)                                      done
    - DAAV6_char_curves_ckt.m (new file)                                    done

    - MVS_1_0_diffpair.m (new file)
    - MVS_diffpair.m (new file)                                             done
    - DAAV6_diffpair.m (new file)
     
 - test-scripts:
    - run_MVS_1_0_defaultparms_char_curves_ckt.m (new file)
            breaks when vgg = 0.1000, vdd = 0
    - run_MVS_1_0_char_curves_ckt.m (new file)                              done
            psis seems to be a memory state !!!!                     
    - run_MVS_char_curves_ckt.m (new file)                                  done
    - run_DAAV6_char_curves_ckt.m (new file)                                done
                                                                     
    - run_MVS_1_0_diffpair_DC_AC_tran.m (new file)                   
    - run_MVS_diffpair_DC_AC_tran.m (new file)                              done
        NR: Jacobian is singular, aborting.
    - run_DAAV6_diffpair_DC_AC_tran.m (new file)
     
3. figure out the differences between MVS 1.0.0 and 1.0.1
    - run a diff                                                            done
    - convert MVS 1.0.1 from MVS 1.0.0
        too many differences, bad idea to convert from 1.0.0
        convert from the VA file instead                                    done
    - carefully compare MVS_1_0_1_ModSpec against mvs_1_0_1.va
        compare between MVS_1_0_1_ModSpec and MVS_1_0_ModSpec  instead      done

4. try MVS_1_0_1_ModSpec

 - ModSpec:
    - MVS_1_0_1_ModSpec.m                                                   done
    - test_MVS_1_0_1_fqei.m                                                 done
    - test_MVS_1_0_1_df.m                                                   done

 - DAEs:
    - MVS_1_0_1_char_curves_ckt.m (new file)                                done
    - MVS_1_0_1_diffpair.m (new file)
     
 - test-scripts:
    - test_MVS_1_0_1_char_curves_ckt.m (new file)                           done
        exactly the same as 1.0.0
    - test_MVS_1_0_1_diffpair_DC_AC_tran.m (new file)

5. read MVS_1_0_1_ModSpec carefully, check for errors                       done
        seems fine to me

6. separate MVS_1_0_1_ModSpec's Q and F evaluation                          done
    - F is separated in MVS_1_0_1_1
      fqei and df seem the same as MVS_1_0_1
      non-convergence was reproduced in char curves

7. add fetlim                                                               done
    - added fetlim in MVS_1_0_1_2, limiting function adopted from SH_MOS
          fetlim is added to Vdb, Vgb, Vsb, most like the way it is added
          in HSPICE
    - changed fetlim in MVS_1_0_1_3
          fetlim is added to Vdib, Vgb, Vsib
          limiting function is in effect, but it still oscillates
    - change fetlim in MVS_1_0_1_4                                         later

8. tweak smoothing
    - use MVS_1_0_1_1_char_curves_ckt but change smoothing to 1e-3, create
      MVS_1_0_1_1_smoothing_char_curves_ckt and
      run_MVS_1_0_1_1_smoothing_char_curves_ckt                             done
          seems exactly the same of before
    - change MVS_1_0_1_1_smoothing_char_curves_ckt and
      run_MVS_1_0_1_1_smoothing_char_curves_ckt smoothing to 1e-1           done
          seems exactly the same of before

        smoothing      description (breaks means non-convergence after 50 iters)
          1e-3, 1e-5     breaks when vgg=0.1, vdd=0
          1e-8           breaks when vgg=0.1, vdd=0
          1e-9           breaks when vgg=0.1, vdd=0
          1e-10          breaks when vgg=0.2, vdd=0
          1e-11          breaks when vgg=0.2, vdd=0
          1e-12          breaks when vgg=0.3, vdd=0
          1e-13          breaks when vgg=0.3, vdd=0
          1e-14          breaks when vgg=0.4, vdd=0
          1e-15          breaks when vgg=0.4, vdd=0
          1e-16          breaks when vgg=0.5, vdd=0
          1e-17          breaks when vgg=0.6, vdd=0

    - implement vecvalder abs(), put it in test system                      done
      move 1.0.1.1 to 1.0.1.5, remove smoothabs, just use abs               done
          by some magic it works!

    - move 1.0.1.5 to 1.0.1.6, add smoothabs to one location                done
    abs() locations in daa_mosfet_core_model:
    524 Vtpcorr = Vt0 + Gamma * (sqrt(abs(phib - Vbs))- sqrt(phib))- Vdsi * delta; % Calculated from extrinsic Vbs
    531 Vt0bs   = Vt0 + Gamma * (sqrt( abs( phib - Vbscorr)) - sqrt( phib ));      % Computed from corrected intrinsic Vbs
    532 Vt0bs0  = Vt0 + Gamma * (sqrt( abs( phib - Vbsi)) - sqrt( phib ));         % Computed from uncorrected intrinsic Vbs
    555 Vdratio    = abs( Vdsi/ Vdsat);
        555 looks most suspicious
        555 is the problem:
            change to smoothabs, DC breaks
            change smoothabs to sqrt(x.*x + smoothing) - sqrt(smoothing);
                it works because abs touches 0 now.

        my suspicions: 

        1) MVS implicitly uses the property that abs() can go to 0
            * where?
            otherwise, the solution may not exist:
            * test this: increase residualtol for NR, it should converge
            exactly!
            smoothing           residualtol          largest vgg that converged
            1e-10               1e-11                0.3
            1e-10               1e-10                0.4
            1e-10               1e-9                 0.5
            1e-10               1e-8                 0.8
            1e-10               1e-7                 0.8
            1e-8                1e-11                0.2
            1e-8                1e-10                0.3
            1e-8                1e-9                 0.4
            1e-8                1e-8                 0.4
            1e-8                1e-7                 0.4
            1e-8                1e-6                 0.4
            1e-8                1e-5                 0.4
            1e-7                1e-11                none
            1e-7                1e-10                0.1
            1e-7                1e-9                 0.2
            1e-7                1e-8                 0.4
            1e-7                1e-7                 0.4
            1e-7                1e-6                 0.4
            1e-7                1e-5                 0.4

            no smoothing, test_MVS_1_0_1_5_char_curves
            vgg     Qinv_corr * vx0 * W / Vdbetabeta  smoothing
                                                    factor when breaks

            0.1000          2.96645e-08               1e-3 to 1e-9  
            0.2000          3.73438e-07               1e-10 to 1e-11
            0.3000          3.99927e-06               1e-12 to 1e-13
            0.4000          2.85928e-05               1e-14 to 1e-15
            0.5000          0.000109912               1e-16        
            0.6000          0.000247625               1e-17        
            0.7000          0.000409545
            0.8000          0.000577789

            sqrt(smoothing) * the second column is almost always 1e-12,
            which is exactly residual tol
            the above charts also show that to change residualtol to 1e-11,
            smoothing need to get down 2 orders

            * test this: move abs from line 555 to the final place of Id
              calculation, use the same residual tol and smoothing factor,
              convergence should be worse.
            see 1.0.1.7, it indeed becomes worse

        2) why vgg matters in convergence:
            it may change Vdsat exponentially
            * test this: plot Vdsat -- vgg
                vgg       Vdsat when converged    smoothing factor when breaks
                0.1000    0.0310752               1e-3 to 1e-9  
                0.2000    0.0416411               1e-10 to 1e-11
                0.3000    0.0695694               1e-12 to 1e-13
                0.4000    0.125768                1e-14 to 1e-15
                0.5000    0.193306                1e-16        
                0.6000    0.237443                1e-17        
                0.7000    0.256122
                0.8000    0.262643

        3) Jacobian may be singular (even not defined) or at least not
           continuous at solution when vdd = 0;
            * test this: plot/print derivatives at vdd = 0
              indeed, without smoothing, derivatives are not smooth at vdd = 0,
              with smoothabs, it is not even continuous!!
                visible in test_MVS_1_0_1_1_df with smoothing larger than 1e-4
              with goodsmoothabs, it is continuous and smooth.
                test_MVS_1_0_1_6_df

     - move 1.0.1.1 to 1.0.1.7, move smoothabs from line 555 to where Id is
       calculated                                                           done

9. test inverter
     - 1.0.1.5 singular
     - move 1.0.1.1 to 1.0.1.8, removed smoothabs, but added fetlim
            also singular
        save J, columns 3, 6, 9 add up to zero column
0.0100       0   -0.0100  1.0000         0         0       0         0   0.0100
     0       0         0       0    1.0000         0       0         0        0
-0.0100      0    0.0200       0         0   -0.0100       0         0  -0.0100
1.0000       0         0       0         0         0       0         0        0
     0  1.0000         0       0         0         0       0         0        0
     0       0   -0.0100       0         0    0.0100       0         0        0
     0       0         0       0         0         0  0.0100         0        0
     0       0         0       0         0         0       0    0.0100        0
0.0100       0   -0.0100       0         0         0       0         0   0.0100
         DAE.unknames(DAE)
        'e_vdd' 'e_in' 'e_out' 'Vdd:::ipn' 'Vin:::ipn' 'NMOS:::vdib' 'NMOS:::vsib' 'PMOS:::vdib' 'PMOS:::vsib'
        3, 6, 9 being
            'e_out' 'NMOS:::vdib' 'PMOS:::vsib'
         non-zeros on the 3,6,9 columns: row 1, 3, 6, 9
        DAE.eqnnames(DAE)
        'KCL_vdd' 'KCL_in' 'KCL_out' 'KVL_Vdd_vpn' 'KVL_Vin_vpn' 'NMOS:::KCL-di' 'NMOS:::KCL-si' 'PMOS:::KCL-di' 'PMOS:::KCL-si'
        1, 3, 6, 9 being
            'KCL_vdd' 'KCL_out' 'NMOS:::KCL-di' 'PMOS:::KCL-si'
     - add an rl in 1.0.1.5
        works for op at Vin = 0.1, dc at 0.1-1, doesn't converge at Vin = 0
        works at 0.1 down to 0. This means with proper init guess, Vin = 0
            converges
        [1;0;1;0;0;1;0;0;0] doesn't converge within 100 iters
        [1;0;1;0;0;1;0.0004;-0.0004;-0.0008] in 2 iters
        [1;0;1;0;0;1;0.0004;-0.0004;0] in 2 iters
        [1;0;1;0;0;1;0.0004;0;0] doesn't converge within 100 iters
        [1;0;1;0;0;1;0;-0.0004;0] in 3 iters
            the 8th unk is 'PMOS:::vdib'
        [0;0;0;0;0;0;0;-0.0004;0] in 5 iters
        [0;0;0;0;0;0;0;-0.0001;0] in 5 iters
        [0;0;0;0;0;0;0;+0.0001;0] in 5 iters
        [0;0;0;0;0;0;0;+0.0000001;0] in 5 iters
            as long as it is not 0, it converges reasonably easily
            It may have something to do with the fact that at Vdisi=0 the
            derivative is not continuous.
     - add an rl in 1.0.1.6 (with smoothing, goodsmoothabs())
            same as 1.0.1.5, convergence slightly worse
     - add an rl in 1.0.1.8 (without smoothing, with fetlim)
            same as 1.0.1.5
     - compare Jacobians at all-zeros and [0;0;0;0;0;0;0;+0.0000001;0]
       with 1.1.0.5
    >> feval(DAE.df_dx, zeros(9,1), [1;0], DAE)
    ans =
    0.0100        0 -0.0100 1.0000      0       0         0         0    0.0100
         0        0       0      0 1.0000       0         0         0         0
   -0.0100        0  0.0200      0      0 -0.0100         0         0   -0.0100
    1.0000        0       0      0      0       0         0         0         0
         0   1.0000       0      0      0       0         0         0         0
         0        0 -0.0100      0      0  0.0100         0         0         0
         0        0       0      0      0       0    0.0100         0         0
         0        0       0      0      0       0         0    0.0100         0
    0.0100        0 -0.0100      0      0       0         0         0    0.0100

    >> feval(DAE.df_dx, [0;0;0;0;0;0;0;+0.0000001;0], [1;0], DAE)
    ans =
    0.0100       0 -0.0100 1.0000      0       0         0         0    0.0100
         0       0       0      0 1.0000       0         0         0         0
   -0.0100       0  0.0200      0      0 -0.0100         0         0   -0.0100
    1.0000       0       0      0      0       0         0         0         0
         0  1.0000       0      0      0       0         0         0         0
         0       0 -0.0100      0      0  0.0100         0         0         0
         0       0       0      0      0       0    0.0100         0         0
    0.0000 -0.0000 -0.0000      0      0       0         0    0.0100   -0.0000
    0.0100  0.0000 -0.0100      0      0       0         0   -0.0000    0.0100
        
        introduced non-zeros: (8, 1), (8, 2), (8, 3), (8, 8), (8, 9) 
        (d) PMOS:::KCL-di (d) e_vdd   e_in   e_out   PMOS:::vdib   PMOS:::vsib 
    - add gmin in 1.0.1.5, move to 1.0.1.9
        MVS_1_0_1_9_inverter_ckt without RL works 
        MVS_1_0_1_5_inverter_ckt without RL doesn't work for singular Jacobian
            This perfectly indicates the need for GMIN!

10. tweak smoothing again
        MVS_1_0_1_5_inverter_ckt without RL doesn't work for singular Jacobian
    - change abs()'s derivative at 0 to be 1                                done
        MVS_1_0_1_5_inverter_ckt without RL works
    - change abs()'s derivative at 0 to be -1                               done
        MVS_1_0_1_5_inverter_ckt without RL works
    - change abs()'s derivative at 0 back to be 0                           done

11. debug MVS_1_0_1_9's problem when Vin:::E = 0
    - find NR trace
    - add fetlim to 1.0.1.9, make 1.0.1.10
        didn't make a difference
        plotlimiting_Vgg0 shows that limiting is not really in effect among
        the oscillation region (vdd = ~0.7 and ~1.8)
    - save Jacobian matrices and debug
        hard to see anything
    x = [1 0 0.728507 5.93341e-05 0 0.73444 -0.00593341 0.00593341 -0.277427]
    dfx =
        0.0100       0 -0.0100 1.0000      0       0       0       0  0.0100
             0       0       0      0 1.0000       0       0       0       0
       -0.0100       0  0.0200      0      0 -0.0100       0       0 -0.0100
        1.0000       0       0      0      0       0       0       0       0
             0  1.0000       0      0      0       0       0       0       0
             0  0.0000 -0.0100      0      0  0.0100 -0.0000       0       0
             0 -0.0000 -0.0000      0      0 -0.0000  0.0100       0       0
        0.0018 -0.0018 -0.0000      0      0       0       0  0.0126 -0.0007
        0.0082  0.0018 -0.0100      0      0       0       0 -0.0026  0.0107

    x = [1 0 1.88243 -8.224e-06 0 1.88161 0.0008224 -0.0008224 0.88325]
    dfx =
        0.0100       0 -0.0100 1.0000      0       0       0       0  0.0100
             0       0       0      0 1.0000       0       0       0       0
       -0.0100       0  0.0200      0      0 -0.0100       0       0 -0.0100
        1.0000       0       0      0      0       0       0       0       0
             0  1.0000       0      0      0       0       0       0       0
             0  0.0006 -0.0100      0      0  0.0101 -0.0007       0       0
             0 -0.0006 -0.0000      0      0 -0.0001  0.0107       0       0
       -0.0019  0.0019 -0.0000      0      0       0       0  0.0104 -0.0024
        0.0119 -0.0019 -0.0100      0      0       0       0 -0.0004  0.0124
    - 1.0.1.10 with gmin >= 1e-3 will converge in 6 iters
    - 1.0.1.10 with Vin = 0.051 will converge, Vin = 0.05 won't
    - 1.0.1.10 with Vin = 0.0505 will converge, Vin = 0.0504 won't
    - when it oscillates, oscillation happens between slightly different points

    - move 1.0.1.3, make 1.0.1.11
    code:
DAE = MNA_EqnEngine(MVS_1_0_1_11_inverter_ckt);DAE = feval(DAE.set_uQSS, 'Vin:::E', 0.0, DAE);qss = dot_op(DAE);
        without init or limiting, doesn't converge
        with only init, converges in 16 iters
        with only limiting, converges in 7 iters
        with both init and limiting, converges in 6 iters

12. try MVS inverter transient
    - without anything, no gmin, no smoothing, no fetlim, no initialization
        1.0.1.5
        transient works
    - with smoothing, no gmin, no fetlim, no initialization
        1.0.1.6, not really necessary, smoothing should be demonstrated in other
        ways
        transient works, no difference from 1.0.1.5, not in speed (not noticable)
    - with gmin, no smoothing, no fetlim, no initialization
        1.0.1.9
        transient works, no difference from 1.0.1.5, not in speed (not noticable)
    - with gmin, with fetlim, with initialization, no smoothing
        1.0.1.11
        - disable limiting
        - disable initialization
        transient works, no difference from 1.0.1.5, not in speed (not noticable)

13. try MVS ring oscillator 3 and 5
    - implement MVSringosc3
    - run transient on it, it doesn't oscillate, even with Ileak
    - run transient in HSPICE, it oscillates, but it won't withouta .ic n1=1
    - with periodic Ileak as large as 1mA, it oscillates...
    * should make transient much faster before moving on
    * figure out .ic statement in MAPP, find equivalent solution

14. try MVS common source amplifier
    everything works with 1.0.1.5
    (try MVS diffpair)

15. start from the oscillation point, see if fetlim fixes the problem

    original oscillation positions:
    x1: [1, 0, 1.88277, -8.22339e-06, 0, 1.88195, 0.000822339, -0.000822339, 0.883591]
    x2: [1, 0, 0.728558, 5.93834e-05, 0, 0.734496, -0.00593834, 0.00593834, -0.27738]

    with only fetlim, no init, started from x2, new oscillation positions:
    [1, 0, 0.751933, 3.64543e-05, 0, 0.755579, -0.00364543, 0.00364543, -0.251712]
    [1, 0, 1.72821, -7.39714e-06, 0, 1.72747, 0.000739714, -0.000739714, 0.728948]

16. remove abs(Vdsi), see what will happen in both HSPICE and MAPP
    abs is probably not necessary
    - remove abs() in abs(Vdsi) in Verilog-A file, char_curves, dc_inverter,
      tran_inverter, ro3, ro5 all work as before

17. plot f based on interpolation between two oscillation points            done

18. Xyce: MVS char_curves and MVSamp work out of box, without gmin, init or
    fetlim
    Xyce: MVS_diffpair doesn't work, updates on q becomes nan after a few iters

19. MVS_diffpair in MAPP: 1.0.1.5 doesn't work, jacobian singular even in first
            iteration
        1.0.1.9 has gmin, starting from all zeros, jacobina not singular at
            first, it update norm of x by 1e+7 after first iter
        1.0.11 works fine: 1) with only init, it doesn't jump that far and
            converges in 4 iters; 2) with only limiting, it jumps by 1e+7 but
            converges a few iters after that.

20. figure out whether we can add fetlim in MVS in Xyce
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later
    difficult to do

21. try use some sort of limiting with sqrt(x) and fix convergence problem with
    it 
    - first build a DAE with f(x, u) = sqrt(x) - u
      difficulty is with infinite slope at x=0, limiting it may cause inconsistency
      between f and df
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later

22. try set initial guess in Xyce
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later

23. make another ModSepc device, say ModSpec_Device2 in Xyce
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later
    put in MVS PMOS
    try to make MVS inverter work
    try to make MVS ringOsc3 and ringOsc5 work

24. add to ModSpec wrapper init/limiting                                    done
    make ModSpec support both the original syntax and the vecLim version
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later

25. move everything to ModSpec wrapper
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later

26. add to DAEAPI wrapper init/limiting                                 
    make DAEAPI support both the original syntax and the xlim version
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                       later









X. put whatever is not needed right now into old/
    old/
        mvs_char_curves_ckt.m
        mvsModSpec.m
        MVS_no_int_nodes_ModSpec.m
        run_mvs_char_curves.m
        test_MNAEqnEngine_MVS_char_curves.m
        test_MNAEqnEngine_MVS_no_int_nodes_char_curves.m
        test_MNAEqnEngine_MVS_no_int_nodes_ringosc_tran.m
        test_MVS_dc_inverter.m
