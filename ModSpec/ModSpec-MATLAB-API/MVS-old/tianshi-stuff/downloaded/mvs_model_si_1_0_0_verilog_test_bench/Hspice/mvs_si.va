// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET
// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.
// charge model: L. Wei et al, p. 1263, T-ED 2012.
// Implemented on July 15, 2013 by S. Rakheja

`include "constants.vams"
`include "disciplines.vams"

module daa_mosfet(d, g, s, b);
inout d,g,s,b;
electrical d,g,s,b;
electrical di, si;


// Original VS parameters
parameter real version = 1.00; 	        		//      MVS model version = 1.0.0
parameter integer tipe = 1 from [-1 : 1] exclude 0;  	//	type of transistor. nFET tipe=1; pFET tipe=-1
parameter real W = 1e-4;	        		//	Transistor width [cm]
parameter real Lgdr = 80e-7;				//	Physical gate length [cm]. 
							//	This is the designed gate length for litho printing.
parameter real dLg = 10.5e-7;				//	Overlap length including both source and drain sides [cm].  
parameter real Cg = 2.2e-6;				//	Gate-to-channel areal capacitance at the virtual source [F/cm^2]
parameter real etov = 1.3e-3; 				//	Equivalent thickness of dielectric at S/D-G overlap [cm]
parameter real delta = 0.10; 				//	Drain-induced-barrier-lowering (DIBL) [V/V]
parameter real n0 = 1.5;				// 	Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}
parameter real Rs0 = 100; 				// 	Access resistance on s-terminal [Ohms-micron]
parameter real Rd0 = 100;				// 	Access resistance on d-terminal [Ohms-micron] 
							//	Generally, Rs0 = Rd0 for symmetric source and drain.
parameter real Cif = 1e-12;				//	Inner fringing S or D capacitance [F/cm] 
parameter real Cof = 2e-13; 				//	Outer fringing S or D capacitance [F/cm] 
parameter real vxo = 0.765e7; 				//	Virtual source injection velocity [cm/s]
parameter real mu = 200; 				//	Low-field mobility [cm^2/V.s]
parameter real beta = 1.7;				//	Saturation factor. Typ. nFET=1.8, pFET=1.6
parameter real phit = 0.0256;				//	Thermal voltage, kT/q [V]
parameter real phib = 1.2; 				//	~abs(2*phif)>0 [V]
parameter real gamma = 0.0;   				//	Body factor  [sqrt(V)]
parameter real Vt0 = 0.486; 				//	Strong inversion threshold voltage [V] 
parameter real alpha = 3.5;				//	Empirical parameter associated with threshold voltage shift
							// 	between strong and weak inversion.

parameter real mc = 0.2 from [0.01 : 10];		// 	Choose an appropriate value between 0.01
                            				//	to 10. For, values outside of this range,
                            				//	convergence or accuracy of results is not
                            				//	guaranteed.

parameter real CTM_select = 1;				// 	if CTM_select = 1, then classic DD-NVSAT
                            				// 	model is used; for CTM_select other than
                            				// 	1,blended DD-NVSAT and ballistic charge
                            				// 	transport model is used. 

parameter real CC = 0;					//	Fitting parameter to adjust Vg-dependent inner fringe capacitances 
							// 	CC is not used in this version.

parameter real nd = 0;    				// 	Punch-through factor [1/V]

`define  SMALL_VALUE  (1e-10)
`define  LARGE_VALUE  (40)  

real Rs, Rd, Vds, Vgs, Vgsraw, Vgd, Vgdraw, Vbs, Vdsi, Vgsi, Vgdi, Vbsi, dir;
real Leff, me, qe, S;
real n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;
real eVg, FF, eVg0, FF0, Qref, eta, eta0;
real Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;
real Vgt, psis, Vgta, Vsatq, Vdsatq, Fsatq, x, den;
real qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;
real Qb, etai, Qinvi, dQinv, dibl, dibl_corr; 
real Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qx, Qy, Qg, a, Cofs, Cofd;



analog begin

Vgsraw		=	tipe*(V(g)-V(si));
Vgdraw		=	tipe*(V(g)-V(di));


if (Vgsraw >= Vgdraw) begin
	Vds	=	tipe*(V(d)-V(s)); 
	Vgs	=	tipe*(V(g)-V(s));
	Vgd	=	tipe*(V(g)-V(d));
	Vbs	=	tipe*(V(b)-V(s));
	Vdsi	=	tipe*(V(di)-V(si));
	Vgsi	=	Vgsraw;
	Vgdi	=	Vgdraw;
	Vbsi	=	tipe*(V(b)-V(si));
	dir	=	1;
end
else begin
	Vds	=	tipe*(V(s)-V(d));
	Vgs	=	tipe*(V(g)-V(d));
	Vgd	=	tipe*(V(g)-V(s));
	Vbs	=	tipe*(V(b)-V(d));
	Vdsi	=	tipe*(V(si)-V(di));
	Vgsi	=	Vgdraw;
	Vgdi	=	Vgsraw;
	Vbsi	=	tipe*(V(b)-V(di));
	dir	=	-1;
end

	Rs	=	1e-4/W*Rs0; // s-terminal resistance [ohms]
	Rd	=	Rs; // d-terminal resistance [ohms] {For symmetric source and drain Rd = Rs.} 
		            // This symmetry may be changed in a future release

	// Rd	=	1e-4/W*Rd0; // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}

    	Cofs = (0.345e-12/etov)*dLg/2.0 + Cof; // s-terminal outer fringing cap [F/cm]
    	Cofd = (0.345e-12/etov)*dLg/2.0 + Cof; // d-terminal outer fringing cap [F/cm]

	Leff 	= 	Lgdr-dLg;  // Effective channel length [cm]			
				  // after subtracting overlap lengths on the source and drain.
	
	me	=	(9.1e-31)*mc;			
			// carrier mass [Kg]
	qe	=	1.602e-19;			
			// electron charge [Coulomb]

	n		=	n0 + nd*Vds;			
			// total subthreshold swing factor taking punchthrough into account [unit-less]
	nphit		= 	n*phit; // product of n and phit [used as one variable]
	aphit		=	alpha*phit; // product of alpha and phit [used as one variable]

	
	// correct Vgsi and Vbsi
	// Vcorr is computed using external Vbs and Vgs but internal Vdsi
	// Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and
	// corrected Vgs, Vbs respectively.
		
	Vtpcorr		=	Vt0+gamma*(sqrt(abs(phib-Vbs))-sqrt(phib))-Vdsi*delta; 
			// calculated from extrinsic Vbs

	eVgpre 		= 	exp((Vgs-Vtpcorr)/(aphit*1.5)); 
			// calculated from extrinsic Vgs

    	FFpre 		= 	1.0/(1.0+eVgpre);
			// only used to compute the correction factor

   	ab		=	2*(1-0.99*FFpre)*phit;  
    	Vcorr		=	(1.0+2.0*delta)*(ab/2.0)*(exp(-Vdsi/ab)); 
			// correction to intrinsic Vgs

	Vgscorr		=	Vgsi+Vcorr; 
			// intrinsic Vgs corrected (to be used for charge and current computation)

	Vbscorr		=	Vbsi+Vcorr; 
			// intrinsic Vgs corrected (to be used for charge and current computation)
	
	Vt0bs		=	Vt0+gamma*(sqrt(abs(phib-Vbscorr))-sqrt(phib)); 
			// computed from corrected intrinsic Vbs
	Vt0bs0		=	Vt0+gamma*(sqrt(abs(phib-Vbsi))-sqrt(phib)); 
			// computed from uncorrected intrinsic Vbs
	Vtp		=	Vt0bs-Vdsi*delta-0.5*aphit; 
			// computed from corrected intrinsic Vbs and intrinsic Vds
   	Vtp0		=	Vt0bs0-Vdsi*delta-0.5*aphit; 
			// computed from uncorrected intrinsic Vbs and intrinsic Vds
	


	eVg		=	exp((Vgscorr-Vtp)/(aphit)); 
			// compute eVg factor from corrected intrinsic Vgs
	FF		=	1.0/(1.0+eVg);
	eVg0		=	exp((Vgsi-Vtp0)/(aphit)); 
			// compute eVg factor from uncorrected intrinsic Vgs
	FF0		=	1.0/(1.0+eVg0);
	Qref		=	Cg*nphit;	
	eta		=	(Vgscorr-(Vt0bs-Vdsi*delta-FF*aphit))/(nphit); 
			// compute eta factor from corrected intrinsic Vgs and intrinsic Vds
	eta0		=	(Vgsi-(Vt0bs0-Vdsi*delta-FFpre*aphit))/(nphit);
			//compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. 
			//Using FF instead of FF0 in eta0 gives smoother capacitances.

		// Computation of charge at VS in saturation (Qinv)
    		if (eta  <= `LARGE_VALUE) begin
			Qinv_corr  	= 	Qref * ln(1.0 + exp(eta));
		end
		else begin
			Qinv_corr	=	Qref*eta;
		end
		
		if (eta0 <= `LARGE_VALUE) begin 
		// compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning
			Qinv		=	Qref*ln(1.0+exp(eta0));
		end
		else	begin
			Qinv		=	Qref*eta0;
		end

	vx0		=	vxo;	


	Vdsats		=	vx0*Leff/mu;							
	Vdsat		=	Vdsats*(1.0-FF) + phit*FF; // saturation drain voltage for current
	Vdratio		=	abs(Vdsi/Vdsat);
	Vdbeta		=	pow(Vdratio, beta);
	Vdbetabeta 	= 	pow(1.0+Vdbeta, 1.0/beta);
	Fsat		=	Vdratio / Vdbetabeta;		
			// transition function from linear to saturation. 
			// Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat
	Id		=	Qinv_corr*vx0*Fsat*W;		// total drain current 

	// calculation of intrinsic charge partitioning factors (qs and qd)
	
	Vgt		=	Qinv/Cg; // Use charge computed from uncorrected intrinsic Vgs
	
	if (gamma == 0) begin
		a = 1.0;
		if (eta0 <= `LARGE_VALUE) begin
		psis = phib+phit*(1.0+ln(ln(1.0+`SMALL_VALUE+exp(eta0))));
		end
		else begin
		psis		=	phib+phit*(1.0+ln(eta0));
	end
	end
	else begin
		a		=	1.0+gamma/(2.0*sqrt(abs(psis-(Vbsi))));
	// Approximate solution for psis is weak inversion	
	if (eta0 <= `LARGE_VALUE) begin
		psis		=	phib+(1.0-gamma)/(1.0+gamma)*phit*(1.0+ln(ln(1.0+`SMALL_VALUE+exp(eta0))));
	end
	else begin	
		psis		=	phib+(1.0-gamma)/(1.0+gamma)*phit*(1.0+ln(eta0));
	end
	end

	Vgta		=	Vgt/a; // Vdsat in strong inversion
	Vdsatq		=	sqrt(FF0*aphit*aphit+Vgta*Vgta);
				// Vdsat approx. to extend to weak inversion; 
				// The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.
				// Vdsatq=(FF0.*(alpha*phit)+(1-FF0).*Vgta + sqrt(FF0.*(alpha*phit).^2+(Vgta).^2))/2;

	// Modified Fsat for calculation of charge partitioning
	Fsatq		=	abs(Vdsi/Vdsatq)/(pow(1.0+pow(abs(Vdsi/Vdsatq),beta),1.0/beta));
	x		=	1.0-Fsatq;
	den		=	15*(1+x)*(1+x);
	qsc 		=	Qinv*(6 + 12*x + 8*x*x + 4*x*x*x)/den;
	qdc		=	Qinv*(4 + 8*x + 12*x*x + 6*x*x*x)/den;
	qi		=	qsc+qdc; // charge in the channel 
	
	
		kq 	= 	0.0;
		tol	= 	(`SMALL_VALUE*vxo/100.0)*(`SMALL_VALUE*vxo/100.0)*me/(2*`P_Q);

	if	(Vdsi <= tol) begin
		kq2	=	(2.0*`P_Q/me*Vdsi)/(vx0*vx0)*10000.0;
		kq4	=	kq2*kq2;
		qsb	=	Qinv*(0.5-kq2/24.0+kq4/80.0);
		qdb	=	Qinv*(0.5-0.125*kq2+kq4/16.0);
	end
	else begin	
		kq	=	sqrt(2.0*`P_Q/me*Vdsi)/vx0*100.0;
		kq2	=	kq*kq;
		qsb	=	Qinv*(asinh(kq)/kq-(sqrt(kq2+1.0)-1.0)/kq2);
		qdb	=	Qinv*((sqrt(kq2+1.0)-1.0)/kq2);
	end
	
	// Flag for classic or ballistic charge partitioning:
	if (CTM_select == 1) begin // classic DD-NVSAT
		qs	=	qsc;
		qd	=	qdc;
	end
	else begin 	// ballistic blended with classic DD-NVSAT
			// Calculation of "ballistic" channel charge partitioning factors, qsb and qdb.
			// Here it is assumed that the potential increases parabolically from the
			// virtual source point, where Qinv_corr is known to Vds-dvd at the drain.
			// Hence carrier velocity increases linearly by kq (below) depending on the
			// efecive ballistic mass of the carriers.
		qs	=	qsc*(1-Fsatq*Fsatq)+qsb*Fsatq*Fsatq;
		qd	=	qdc*(1-Fsatq*Fsatq)+qdb*Fsatq*Fsatq;
	end

	// Body charge based on approximate surface potential (psis) calculation.
	// With delta=0 using psis=phib in Qb gives continuous Cgs, Cgd, Cdd in SI,
	// while Cdd is smooth anyway.
	
	Qb 	=	-tipe*W*Leff*(Cg*gamma*sqrt(abs(psis-Vbsi))+(a-1.0)/(1.0*a)*Qinv*(1.0-qi));

	// DIBL effect on drain charge calculation
	// Calculate dQinv at virtual source due to DIBL only.  Then: 
	// Correct the qd factor to reflect this channel charge change due to Vd

	etai 	=	(Vgsi-(Vt0bs0-FF*aphit))/(nphit);
	// Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 
	// (in weak inversion.  But bad in strong inversion)
	
	if (etai <= `LARGE_VALUE) begin
		Qinvi	=	Qref*ln(1.0+exp(etai));
	end
	else begin
		Qinvi	=	Qref*etai;
	end

	dQinv		=	Qinv-Qinvi;
	dibl_corr	=	(1.0-FF0)*(1.0-Fsatq)*qi*dQinv;
	qd		=	qd-dibl_corr;

		 
	// Inversion charge partitioning to terminals s and d
	Qinvs		=	tipe*Leff*((1+dir)*qs+(1-dir)*qd)/2.0;
	Qinvd		=	tipe*Leff*((1-dir)*qs+(1+dir)*qd)/2.0;


	// Outer fringing capacitance
	Qsov		=	Cofs*(V(g)-V(si));
	Qdov		=	Cofd*(V(g)-V(di));

	// Inner fringing capacitance
	Vt0x		=	Vt0+gamma*(sqrt(abs(phib-tipe*(V(b)-V(si))))-sqrt(phib));
	Vt0y		=	Vt0+gamma*(sqrt(abs(phib-tipe*(V(b)-V(di))))-sqrt(phib));
	Fs_arg		=	(Vgsraw-(Vt0x-Vdsi*delta*Fsat)+aphit*0.5)/(1.1*nphit);
	if (Fs_arg <= `LARGE_VALUE) begin
		Fs	=	1.0+exp(Fs_arg);
		FFx	=	Vgsraw -nphit*ln(Fs);
	end
	else begin
		Fs	=	0.0;  //not used
		FFx	=	Vgsraw-nphit*Fs_arg;
	end

	Fd_arg		=	(Vgdraw-(Vt0y-Vdsi*delta*Fsat)+aphit*0.5)/(1.1*nphit);
	if (Fd_arg <= `LARGE_VALUE) begin
		Fd	=	1.0+exp(Fd_arg);
		FFy	=	Vgdraw-nphit*ln(Fd);
	end
	else begin
		Fd	=	0.0; 	// not used
		FFy	=	Vgdraw-nphit*Fd_arg;
	end
	
	Qsif		=	tipe*(Cif+CC*Vgsraw)*FFx;
	Qdif		=	tipe*(Cif+CC*Vgdraw)*FFy;
		
	
	// partitioned charge
	
	Qs	=	-W*(Qinvs+Qsov+Qsif); 	// s-terminal charge
	Qd	=	-W*(Qinvd+Qdov+Qdif); 	// d-terminal charge
	Qg	=	-(Qs+Qd+Qb);		// g-terminal charge

    	I(di,si) <+ tipe*dir*Id;
    	I(d,di) <+ (V(d)-V(di))/Rd;
    	I(si,s) <+ (V(si)-V(s))/Rs;

	I(si,b) <+ ddt(Qs);		// charge term: node si to node b
	I(di,b) <+ ddt(Qd);		// charge term: node di to node b
	I(g,b) <+ ddt(Qg);		// charge term: node g to node b


end
endmodule

	
	


